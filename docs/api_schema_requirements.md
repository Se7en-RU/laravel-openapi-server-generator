## Правила по написанию файлов документации

### 1. Файлы и названия
Важно понимать, что генератором генерируются классы только из
- #/components/schemas/Model
- Отдельных файлов, которые подключены через $ref в индексный файл
Причем название будущего класса будет соответствовать названию файла (транслированному в камельКейс) или названию схемы
Для классов реквестов/респонсов желательно в названии класса в конце добавлять перфикс Request/Response.
В описании каждого эндпоинта обязательно нужно указывать tags и operationId.

### 2. Директории
Все yaml файлы располашаются в папке указаной в конфиге в поле `apidoc_dir`.
Внутри должна быть следующая структура:
`index.yaml` - Все эндпоинты описываются в этом файл. Так же сюда подключаются все модел, для которых нужно сгенерировать Dto, они указываются в /components/schemas.
Так как генератор вычисляет путь до файлов, на которые ссылаются через $ref, по относительному пути от директории, в которой находится index.yaml, а, например пакет swagger-ui вычисляет путь онтсительно текущего файла, в котором используется $ref необходимо, что бы все файлы спецификации находились на одном уровне вложенности, соответственно группировать объекты схемы по директориям не получится. Один из выходов группировать по файлам: common.yaml -  для описания общих моделей схемы, restQuery.yaml - описание моделей для RestQuery и так далее. Подключение моделей между файлами можно организовать через Remote Reference: https://swagger.io/docs/specification/using-ref/ смотри пункт '$ref Syntax'
Так как Enum модели подвергаются патчингу, о чем более подробно указанно ниже, для их описания для каждого enum нужно использовать отдельный файл. Такие файлы должны иметь название по шаблону {enum_name_in_snake_case}_enum.yaml.

Пример организации документации можно посмотреть [здесь](https://github.com/greensight/laravel-openapi-server-generator/tree/master/tests/api-docs)

C enum есть 2 проблемы
1. По сути это свойство с типом integer. Но генератором оно генерируется как отдельный класс, из-за того что мы выносим перечисление отдельным файл и потом подключаем везде. И соответственно требует в свойствах в качестве значения этот класс. А мы не может число определить как этот сгенерированный класс.
2. При числовых перечисления класс генерируется с синтаксической ошибкой https://github.com/OpenAPITools/openapi-generator/issues/1475

Для решения этих проблем
1. Под каждый enum создаём файл с названием {banana}_enum.yaml в директории public/api-docs/components/
2. Содержимое файла должно быть следующего вида:
```
type: number
description: >
    Роли. Расшифровка значений:
     * Роли админки:
     * `101` - Супер-администратор
     * `102` - Администратор
     * `113` - Оператор колл-центра
     * `115` - Администратор магазина
     * Роли витрины:
     * `403` - Неавторизованный пользователь
enum:
    - 101 # ADMIN__SUPER | Супер-администратор
    - 102 # ADMIN__ADMIN | Администратор
    - 113 # ADMIN__OMS_CALL_CENTER | Оператор колл-центра
    - 115 # ADMIN__MERCHANT_ADMINISTRATOR | Администратор магазина
    - 403 # SHOWCASE__GUEST | Неавторизованный пользователь
```
Важно заполнение свойства enum. Необходимо четко придерживаться шаблона выше: `- <value> # <name> | <comment>`.  Здесь value -  значение перечисления, name - название, title - комментарий в одну строку.
3. В index.yaml подключаем наш файл в качестве компонента с названием {Banana}Enum и нигде не используем
4. Во всех местах, где наше перечисление должно быть свойством (например order.banana_id), то указываем banana_id просто как числовое поле, БЕЗ enum.

### 3. index.yaml
1. Все объекты запросов и ответов выносятся в отдельные файлы и подключаются напрямую.
2. У всех операций должен быть тег.
3. В #/components/schemas допустимо выносить модели, которые нигде не используются, но хотелось бы получить при генерации под них класс.
